/**
 * @Time : 2022/8/24-11:05 AM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 
 */
#include<bits/stdc++.h>
using namespace std;
/**
 * 给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = '0' 表示第 i 节车厢 不 含违禁货物，而 s[i] = '1' 表示第 i 节车厢含违禁货物。

作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：

从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。
从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。
从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。
返回移除所有载有违禁货物车厢所需要的 最少 单位时间数。

注意，空的列车车厢序列视为没有车厢含违禁货物。

 

示例 1：

输入：s = "1100101"
输出：5
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
示例 2：

输入：s = "0010"
输出：2
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
 

提示：

1 <= s.length <= 2 * 105
s[i] 为 '0' 或 '1'

来源：力扣（LeetCode）
链接：https://algorithm.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods
 */
class Solution {
public:
    /**
     * 本题在数据量小的情况下，可以枚举左右两条切割点，中间的1都用直接移除的方式
     * 但是这样时间复杂度是n^2，在本题的数据范围下会超时
     *
     * 那退而求其次，枚举单边的切割点，假定枚举右边的切割点
     * （对称的，枚举左边的切割点和右边的切割点没有区别）
     * 右边的切割点为j, 切割了[j, n - 1]，花费是n - j
     * 还剩下[0, j - 1]要考虑如何完成切割，左边切割掉一部分前缀，剩余部分中的1都花费2成本拿走
     * 现在不允许枚举左边的切割线，那问题就变为 切割[0, j - 1]的最小成本
     *
     * 在枚举j的时候，随着j的增大，我们要得出一系列[0, j - 1]的最小成本
     * 切割[0,0], [0,1], [0,2],....,[0,n-1]的最小成本这一系列的问题都需要回答
     * 定义状态dp[i]表示切割[0,i]的最小成本
     * dp[i]有两种类型的可能：
     * 1.直接将[0,i]一个一个从左边移除，成本 i - 0 + 1
     * 2.不是从左边进行移除，而是将s[i]当作中间车厢进行移除，耗费2 （当然如果）,并且加上s[0,i-1]的移除成本
     *
     * 当然如果s[i] = 0, 这个车厢不用移除，成本和截止s[i-1]的一致
     */
    int minimumTime(string s) {
        int n = s.size();
        vector<int> dp(n, 0);
        dp[0] = s[0] - '0';
        for(int i = 1; i < n; i++){
            if(s[i] == '0') dp[i] = dp[i - 1];
            else dp[i] = min(dp[i - 1] + 2, i + 1);
        }
        int res = n; // 全部移除的情况，也就是右边分割线处于位置0的情况
        // 枚举右边分割线
        for(int i = 1; i <= n; i++)
            res = min(res, dp[i - 1] + n - i);
        return res;
    }
};

int main(){
    Solution s;
    
    cout << 0 << endl;
}
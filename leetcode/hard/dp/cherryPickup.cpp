/**
 * @Time : 2022/7/11-4:52 PM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 
 */
#include<bits/stdc++.h>
using namespace std;

/**
 * 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
-1 表示这个格子里有荆棘，挡着你的路。
你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：

从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。
示例 1:

输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释：
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
说明:

grid 是一个 N * N 的二维数组，N的取值范围是1 <= N <= 50。
每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。
可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。

来源：力扣（LeetCode）
链接：https://algorithm.cn/problems/cherry-pickup
 */
class Solution {
public:
    /**
     * 741题 经典线性dp的运用题
     * 从右下角走回左上角，和从左上角走到右下角没区别，只不过第一次走的时候会将1变为0
     * 可以转化为两个人同时从左上角走到右下角
     * 定义 dp[k][i1][i2] 为单人走了k步（横纵坐标之和）时，两人行坐标分别为i1,i2时所获的最大樱桃数
     *
     * 初始状态为dp[0][0][0] = grid[0][0]
     *
     * 假定矩阵grid的行数为n
     * 那么答案就是dp[2n - 2][n - 1][n - 1]
     *
     * 转移方程：
     * k的维度显然时用从k-1步转移得到
     * 由于两个人都可以从k-1步向下或者向右走到第k步，因此一共有四种组合
     * 1.(上边，上边)->当前： dp[k-1][i1-1][i2-1] -> dp[k][i1][i2]
     * 2.(上边，左边)->当前： dp[k-1][i1-1][i2] -> dp[k][i1][i2]，注意从左边走过来的那个人，行号不变
     * 3.(左边，上边)->当前： dp[k-1][i1][i2-1] -> dp[k][i1][i2]
     * 4.(左边，左边)->当前： dp[k-1][i1][i2] -> dp[k][i1][i2]
     * 四种情况取最大，再加上当前点的樱桃。注意如果两个人的坐标不一样就分别计算樱桃，如果两个人的坐标一样，就只计算一次樱桃
     *
     * 另外注意有一些地方不能通过，要让这些地方无法转移，可以设置这些地方的樱桃值为一个大负数
     * 这样该点的状态就不会影响到其它点的状态，就等价于不会从这个点走过去
     * （同样在循环中下标越界的，也如此处理，保证非法状态不会参与到计算中）
     */
    int min_val = -100000;
    int cherryPickup(vector<vector<int>>& grid) {
        int n = grid.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == -1)
                    grid[i][j] = min_val;
            }
        }
        vector<vector<vector<int>>> dp = vector(2 * n - 1, vector(n, vector(n, 0)));
        dp[0][0][0] = grid[0][0];
        for(int k = 1; k < 2 * n - 1; k++){
            vector<vector<int>>& preK = dp[k - 1];
            // 循环条件要保证行号和列号都小于n,且大于等于0; j = k - i < n  --> i > k - n --> i >= k - n + 1
            for(int i1 = max(0, k - n + 1); i1 < n && k - i1 >= 0; i1++){
                for(int i2 = max(0, k - n + 1); i2 < n && k - i2 >= 0; i2++){
                    int t1 = check(k - 1, i1 - 1, i2 - 1) ? preK[i1 - 1][i2 - 1] : min_val;
                    int t2 = check(k - 1, i1 - 1, i2) ? preK[i1 - 1][i2] : min_val;
                    int t3 = check(k - 1, i1, i2 - 1) ? preK[i1][i2 - 1] : min_val;
                    int t4 = check(k - 1, i1, i2) ? preK[i1][i2] : min_val;
                    dp[k][i1][i2] = max(max(t1, t2), max(t3, t4));
                    int j1 = k - i1, j2 = k - i2;
                    if(i1 == i2) dp[k][i1][i2] += grid[i1][j1];
                    else dp[k][i1][i2] += grid[i1][j1] + grid[i2][j2];
                }
            }
        }
        // 最后不能忘记结果如果是负数，说明无法到达右下角，返回0
        return dp[2 * n - 2][n - 1][n - 1] < 0 ? 0 : dp[2 * n - 2][n - 1][n - 1];
    }

    bool check(int k, int i1, int i2){
        return i1 >= 0 && k - i1 >= 0 && i2 >= 0 && k - i2 >= 0;
    }
};

int main(){
    Solution s;
    vector<vector<int>> grid = {{0,1,-1},{1,0,-1},{1,1,1}};
    s.cherryPickup(grid);
    cout << 0 << endl;
}
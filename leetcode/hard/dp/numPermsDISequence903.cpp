/**
 * @Time : 2023/4/27-10:46 AM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 
 */
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    /*
     * 考虑已经用 0,1,2,3 排列出满足DID的序列
     * 先考虑排出满足DIDI的序列，新的数字是4
     *
     * 显然 4直接放在原序列最后，一定满足I（上升） 前置数字集合(0,1,2,3)
     * 但是序列还可能以3 2 1 0 结尾
     * 以3结尾，且满足I，那么前一个数字可以是0,1,2 不能为4，前置数字集合(0,1,2,4)
     * 以2结尾，且满足I，那么前一个数字可以是0,1 不能为3,4，前置数字集合(0,1,3,4)
     * ...
     * 前置集合都满足 DID， 即以4个大小不同的元素，大小关系满足DID
     * 只限制大小关系，于数字的绝对大小无关，只有相对大小有关
     * 在只关注相对大小的情况下，对于(0,1,2,4)和(0,1,3,4), 按大小关系重新编号为(0,1,2,3)来排列即可
     * 因此用(0,1,2,3)、(0,1,2,4)、(0,1,3,4)排列出满足DID的序列，其排列方法，排列方法数都一致
     *
     * 并且注意：
     * 以3结尾时，前置数字集合(0,1,2,4)，映射为(0,1,2,3)来排列
     * 比3小的数字并未在映射中变化，不影响前一位以0,1,2结尾的方案数
     * 以2结尾时，前置数字集合(0,1,3,4)，映射为(0,1,2,3)来排列
     * 比2小的数字并未在映射中变化，不影响前一位以0,1结尾的方案数
     * ....
     * 也就是说 当前以数字j结尾，前置数字集合(0,1,...,j-1, j+1,...,n) 映射到 (0,1,...,n)
     * 比j小的数字并未在映射中变化，不影响前一位以0,1,...,j-1结尾的方案数
     *
     * 定义 dp[i][j] 为截止s[i]，以数字j结尾的方案数。
     * 还是以s[i] = I为例子
     * dp[i][0] = 0, 前一位不可能有比0更小的数字
     * dp[i][1] = dp[i - 1][0]
     * dp[i][2] = dp[i - 1][0] + dp[i - 1][1]， 前一位更小的数字可以是0,1
     *          = dp[i][1] + dp[i - 1][1]
     * dp[i][3] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]
     *          = dp[i][2] + dp[i - 1][2]
     * ....
     * dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]
     *
     * 排出满足DIDI的序列，新的数字是4
     * 序列可能以 0 1 2 3结尾
     * 以1结尾时，且满足D，那么前一个数字可以是 2 3 4，前置数字集合(0,2,3,4)
     * 前置数字集合 按大小关系重新编号为(0,1,2,3)来排列
     * 比1大的数字映射中都减小1，因此以2 3 4 为结尾的方案数目，在前置排列中是以1 2 3结尾
     * 此时转移方程为
     * dp[i][4] = 0
     * dp[i][3] = dp[i - 1][3]
     * dp[i][2] = dp[i - 1][3] + dp[i - 1][2]
     *          = dp[i][3] + dp[i - 1][2]
     * dp[i][1] = dp[i - 1][3] + dp[i - 1][2] + dp[i - 1][1]
     *          = dp[i][2] + dp[i - 1][1]
     * ....
     * dp[i][j] = dp[i][j + 1] + dp[i - 1][j]
     *
     *
     * 另外，为了方便 可以将s设置哨兵 s = " " + s
     */
    int numPermsDISequence(string s) {
        s = " " + s;
        int n = s.size(), mod = 1e9 + 7;
        vector<vector<long>> dp(n, vector(n, 0l));
        dp[0] = vector(n, 1l);
        for(int i = 1; i < n; i++){
            // 外层枚举到i时，内层要排列的数字就是(0~i)，因此内循环j的范围时[0,i]
            if(s[i] == 'I') {
                for(int j = 1; j <= i; j++)
                    dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % mod;
            } else {
                for(int j = i - 1; j >= 0; j--) {
                    dp[i][j] = (dp[i][j + 1] + dp[i - 1][j]) % mod;
                }
            }
        }
        long res = 0;
        for(int i = 0; i < n; i++)
            res = (res + dp[n - 1][i]) % mod;
        return res;
    }
};

int main(){
    Solution s;
    
    cout << 0 << endl;
}
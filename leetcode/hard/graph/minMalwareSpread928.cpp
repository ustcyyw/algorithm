/**
 * @Time : 2022/11/7-4:35 PM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 
 */
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    /**
     * 图论 dfs的做法
     */
//    int n;
//    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
//        n = graph.size();
//        vector<vector<int>> g(n, vector(0, 0));
//        for(int i = 0; i < n; i++){
//            for(int j = 0; j < n; j++)
//                if(graph[i][j]) g[i].push_back(j);
//        }
//        int cnt = INT_MAX, ans = -1;
//        for(int v : initial){
//            int temp = count(g, initial, v);
//            if(temp < cnt) {
//                ans = v;
//                cnt = temp;
//            }
//            else if(temp == cnt) ans = min(ans, v);
//        }
//        return ans;
//    }
//
//    int count(vector<vector<int>>& g, vector<int>& initial, int v){
//        vector<bool> marked(n, false);
//        marked[v] = true;
//        int sum = 0;
//        for(int w : initial)
//            if(!marked[w]) sum += dfs(g, marked, w);
//        return sum;
//    }
//
//    int dfs(vector<vector<int>>& g, vector<bool>& marked, int v){
//        marked[v] = true;
//        int cnt = 1;
//        for(int w : g[v])
//            if(!marked[w]) cnt += dfs(g, marked, w);
//        return cnt;
//    }

    /**
     * 并查集
     * 除去感染病毒的结点，先用并查集处理出连通分量，就算出每个分量的大小
     * 但是这个矩阵不一定是对称矩阵，怎么处理链接呢？
     *
     * 然后遍历病毒结点，查看每个连通分量能被多少个病毒感染
     * 如果某个连通分量仅能被一个病毒感染，那么除去该病毒就能减少该连通分量的感染
     * 某个病毒独立感染的越多，除去该病毒，不被感染的结点就最多
     */
//    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial){
//
//    }
};

int main(){
    Solution s;
    
    cout << 0 << endl;
}
/**
 * @Time : 2023/3/14-8:17 PM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 
 */
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> G(n, vector(0, 0));
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++)
                if(graph[i][j])
                    G[i].push_back(j), G[j].push_back(i);
        }
        vector<bool> virus(n, false), marked(n, false);
        for(int num : initial)
            virus[num] = true;
        vector<int> cnt(n, 0);
        sort(initial.begin(), initial.end());
        int res = initial[0], id = 0, val = 0;
        for(int v : initial){
            if(marked[v]) continue;
            int t = dfs(G, virus, marked, cnt, v, id);
            if(cnt[id++] > 1) continue; // 同一个连通分量中有超过2个病毒源头 去掉了也没用
            if(t > val){
                val = t;
                res = v;
            }
        }
        return res;
    }

    int dfs(vector<vector<int>>& graph, vector<bool>& virus, vector<bool>& marked, vector<int>& cnt, int v, int id){
        if(virus[v]) cnt[id]++;
        marked[v] = true;
        int ans = 1;
        for(int w : graph[v]){
            if(marked[w]) continue;
            ans += dfs(graph, virus, marked, cnt, w, id);
        }
        return ans;
    }
};

int main(){
    Solution s;
    
    cout << 0 << endl;
}
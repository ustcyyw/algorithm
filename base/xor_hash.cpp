/**
 * @Time : 2024/10/10-10:32 PM
 * @Author : yyw@ustc
 * @E-mail : yang0@mail.ustc.edu.cn
 * @Github : https://github.com/ustcyyw
 * @desc : 异或哈希
 *
 * 参考博客 https://blog.csdn.net/notonlysuccess/article/details/130959107
 */
#include<bits/stdc++.h>
using namespace std;
/*
 * 问题引入 问某个区间上不同的数是否出现了偶数次
 *
 * 1.容易想到利用异或的性质：两个数异或为0
 * 如果区间上的数成对出现，区间异或就是0；但是反之 由区间异或值为0并不能推出该区间上的数成对出现
 * 比如 [4,8,12], [1,2,4,7]异或都是0 但是数字都只出现了一次
 *
 * 造成反推不成立的原因是 所构造的例子有效的二进制位太少 并且人为构造
 * 但是如果能将一组数映射到另外一组范围很大的随机数
 * 就能使有效的二进制位增加，并且将人为构造的数字打乱
 * （这个打乱的思路很像快排首先进行一次随机排序 就能从概率上认为最坏情况不可能出现）
 * 2.于是想到可以使用哈希将异或的结果集扩大 降低冲突概率
 * 这样从概率上就可以认为区间异或和为0 那么该区间上的数字成对出现
 */

/*
 * 常用的hash映射方法
 * 将1～n的数字进行映射
 */
const int N = 1e6 + 5;
uint64_t code[N];
/*
 * mt19937_64 rnd(time(0))，这是 c++ 自带的梅森旋转（Mersenne Twister）伪随机数
 * 可以随机生成 64 位整数，随机的内容直到 2^19937次调用后才会出现
 */
mt19937_64 rnd(time(0));
int init = []() -> int {
    for (int i = 1; i < N; i ++)
        code[i] = rnd();
    return 0;
}();
// 基础问题例题 https://codeforces.com/contest/2014/problem/H

/*
 * 问题进阶
 * 利用异或和求解区间上数是否出现偶数次 本质上是因为异或和是二进制下不进位加法
 * 推广 如果定义k进制下的不进位加法 可以求解区间上的数是否出现了k的倍数次
 * k进制不进位加法的函数 xor_k
 * 但是这样的做法常数较大，可以用一种巧妙的方式来替代
 * 对于某个特定的数a 其出现第k的倍数次时就用-(k-1) * a替代
 * 这样如果区间范围内出现了k的倍数次a，他们的加和就是0 于是可以用区间和来代替k进制的不进位加法
 * 比如k=3时 a第1、2次出现还是取a，第三次出现取-2a，那么如果区间内a出现了3次
 * 转换后区间上这三个a对应的和就是 a + a -2a = 0
 * 当然 为了避免冲突发生 以上都是建立在先hash映射的基础上
 */
// 特别注意，随机数 a,b 上限要取 uint64/k，避免溢出
// 只有2进制的溢出会自动处理，因为就少了一位，而 k 进制溢出就会出错
uint64_t xor_k(uint64_t a, uint64_t b, int k) {
    vector<int> vec;
    while (a || b) {
        vec.push_back((a + b) % k);
        a /= k;
        b /= k;
    }
    uint64_t res = 0, p = 1;
    for (int x: vec) {
        res += p * x;
        p *= k;
    }
    return res;
}

/*
 * 基础问题变形 问区间上的数的乘积是否为平方数
 * 其实就是问区间上的数分解质因数后 这些质因数是否成对出现
 * 可以将可能的质因子都分解出来 将质因子进行hash映射
 * 然后将每个数按分解出的质因子进行异或 得到这个数的异或值 再用这个值做区间异或即可
 */

class Solution {
public:
    
};

int main(){
    Solution s;
    
    cout << 0 << endl;
}